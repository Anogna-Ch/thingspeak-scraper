{"url": "https://community.thingspeak.com/forum/arduino/page-1/", "threads": [{"url": "https://community.thingspeak.com/forum/arduino/write-multiple-fields-all-at-once-using-thingspeak-library/", "posts": [{"date": "August 12, 2018 - 6:21 pm", "content": "When using the following function from thingspeak lib, it works, data are displayed to thingspeak : ThingSpeak.writeField(myChannelNumber, 1, Temp, myWriteAPIKey)Now, when using the function ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey) along with  ThingSpeak.setField(1,Temp), nothing is displayed.Any advise would be appreciated ; I've attached the code below.Chris#include#include#include#include#include#include 'ThingSpeak.h'HDC1000 mySensor;// MAC address for your Ethernet shieldbyte mac[] = { 0x90, 0xA2, 0xDA, 0x0D, 0xD8, 0x2E };// Thinkspeak to upload dataunsigned long myChannelNumber = 394883;const char * myWriteAPIKey = 'D5VW1M5CUC6XWSSG';// Set the Ethernet library structures :EthernetClient client;// Declares variables and other fixed values :float WatchDog = 0;unsigned long PreviousClicksMillis;int uTemp;int uHumidity;int udp;int uWindSpeed;unsigned volatile int Clicks = 0; // interrupt number 0 on digital pin 2int SAMPLING_RATE = 1000; // Sampling rate in msint T = 30 * SAMPLING_RATE; // Integration time in sfloat N = float(T / SAMPLING_RATE); // Number of samples per integration timevoid setup(){   // Start Serial Monitor   Serial.begin(9600);   Serial.println('Starting Datapod init!');   // Init HDC1000 sensor :   mySensor.begin();   // Inititiate Click count for WindSpeed measurement   attachInterrupt(0, clicker, RISING);   PreviousClicksMillis = millis();   // Initializing network   while (Ethernet.begin(mac) != 1)     {      Serial.println('Error getting IP address via DHCP, trying again ...');      delay(15000);     }   // Network success message :   delay(2000);   Serial.print('Network initialized with the following IP address : ');   // Print the local IP address :   for (byte thisByte = 0; thisByte < 4; thisByte++)     {      // Print the value of each byte of the IP address:      Serial.print(Ethernet.localIP()[thisByte], DEC);      Serial.print('.');      }   Serial.println(); Serial.println();     // Initializing Thingspeak :   ThingSpeak.begin(client);}void loop(){    // Init values :    float Temp = 0.;    float Humidity = 0.;    float WindSpeed = 0.;    float dp = 0.; // Dewpoint    for (int Sampler = 0 ; Sampler < T ; Sampler += SAMPLING_RATE)      {        // Clicks and Rotates timing references :        unsigned long loopstart = millis();        //        Temp += mySensor.getTemp();        Humidity += mySensor.getHumi();        //        unsigned long loopend = millis();        delay(SAMPLING_RATE - (loopend - loopstart)); //  T)      {       unsigned long now = millis();       float CountTime = (now - PreviousClicksMillis) / 1000.0;       // Serial.println(CountTime); // For debug purpose only       WindSpeed = .765 * ((float) Clicks / CountTime);       // WindSpeed = (float) Clicks / 1.; // For debug purpose only       Clicks = 0;       PreviousClicksMillis = now;      }    // WatchDog :    WatchDog += 1;    // Thingspeak    /*ThingSpeak.writeField(myChannelNumber, 1, Temp, myWriteAPIKey);    ThingSpeak.writeField(myChannelNumber, 2, Humidity, myWriteAPIKey);    ThingSpeak.writeField(myChannelNumber, 3, dp, myWriteAPIKey);    ThingSpeak.writeField(myChannelNumber, 4, WindSpeed, myWriteAPIKey);    ThingSpeak.writeField(myChannelNumber, 5, WatchDog, myWriteAPIKey); */    ThingSpeak.setField(1,Temp);    ThingSpeak.setField(2,Humidity);    ThingSpeak.setField(3,dp);    ThingSpeak.setField(4,WindSpeed);    ThingSpeak.setField(5,WatchDog);    ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey);     }// Functions :// COUNT clicks from anemometervoid clicker() {   Clicks++; }", "num_user_post": " 1", "author": "cotixtof"}, {"date": "August 13, 2018 - 4:20 pm", "content": "If you use the code above, you will violate the update rate.Each thingspeak.writeField() counts as an update.  If you have a paid license, you need at least 1 second of delay between each write.  If you have a free account you need 15 seconds.You can use ThingSpeak.setField() five times in a row without waiting, but each  ThingSpeak.writeFields() also counts as an update.  Since there was just a writeField() behind it, it would violate the update frequency.Did you commented out the ThingSpeak.writefields() when you tested?Also, I noticed in your data that there are line feeds in your field 5 data i.e. '400'  Are these on purpose?  They may make your field 5 ThingSpeak plots not function correctly.", "num_user_post": " 401", "author": "cstapels"}]}, {"url": "https://community.thingspeak.com/forum/arduino/updating-thingspeak-channel-with-float-using-get/", "posts": [{"date": "July 20, 2018 - 11:37 am", "content": "Hey guys,I'm using a SIM5320A shield to collect sensor data and send it to my thingspeak channel. Up to yesterday, I was just sending random numbers to get everything working, and no wI have hooked up my sensor and want to send those values (floats turned to char arrays) to the channel. For some reason, my shield gives me the OK that it has sent to thingspeak, but my channel does not get updated.", "num_user_post": " 1", "author": "elaghouh"}, {"date": "July 20, 2018 - 2:37 pm", "content": "Are you getting the response code?  Can you show the format you are using for the API call?", "num_user_post": " 401", "author": "cstapels"}]}, {"url": "https://community.thingspeak.com/forum/arduino/updating-multiple-thingspeak-fields-with-forced-timestamp/", "posts": [{"date": "July 12, 2018 - 10:48 am", "content": "HelloFirst post in this forum, let me know if I should have posted in a different location.I am trying to send data to Thingspeak retrospectively, with a forced timestamp. I intent to use Arduino, and specifically the two functions 'ThingSpeak.setField' followed by 'ThingSpeak.writeFields(myChannelNumber_02, myWriteAPIKey_02);'I understand how to send data and let Thingspeak specifies automatically the time value when the function gets called.However, I would like to be able to retrospectively add data points in ThingSpeak for specific chosen timestamps.Is there a way to do this?Thanks in advanceMax", "num_user_post": " 2", "author": "maximelanoelle"}, {"date": "July 12, 2018 - 4:20 pm", "content": "Looks like a perfect place to post.You can use the setCreatedAt()  in the ThingSpeak Communication library.i.e. ThingSpeak.setCreatedAt('2017-01-06T13:56:28');You can find the documentation for all the available functions in your Arduino libraries folder, then look in thingSpeak , extras and then class_thing_speak_class.htmlhere is the partial path:/Arduino/libraries/ThingSpeak/extras/documentation/class_thing_speak_class.html", "num_user_post": " 401", "author": "cstapels"}, {"date": "July 17, 2018 - 6:16 pm", "content": "Thanks for the help :). This was exactly the command I was after. Now I just need to figure out how to convert my RTC time to the format you specified.Cheers. Max", "num_user_post": " 2", "author": "maximelanoelle"}, {"date": "July 17, 2018 - 8:04 pm", "content": "search for an arduino time library.  There are a bunch of libraries that help you do almost any crazy time operation you want to do.  You just have to sift through the doc or examples, but they have it.  Time formatting is the stuff of many of my recurring programming nightmares.You can also just do string manipulation on it yourself, but I guarantee it will be wrong after daylight savings or every other leap year, etc. (not recommended)And thanks for letting us know it worked!", "num_user_post": " 401", "author": "cstapels"}]}, {"url": "https://community.thingspeak.com/forum/arduino/sending-and-reading-voltage-values-from-the-arduino-due-to-thingspeak-cloud-via-esp8266/", "posts": [{"date": "July 10, 2018 - 7:45 pm", "content": "Need help in reading and writing voltage values on my thingspeak channel. I keep getting ''esp8266' was not declared in this scope' error. It would be appreciated if someone can help me by tonight.here is the code that I used:const float referenceVolts = 3.3;const int batteryPin = 0;#include 'Arduino.h'#include 'ThingSpeak.h'#define DEBUG true //show messages between ESP8266 and Arduino in serial port, when set to true#define SSID 'CACT'#define PASS 'VOSTRO022a'String sendAT(String command, const int timeout, boolean debug){  String response = '';  esp8266.print(command);  long int time = millis();  while ( (time + timeout) > millis())  {    while (esp8266.available())    {      char c = esp8266.read();      response += c;    }  }  if (debug)  {    Serial.print(response);  }  return response;}void setup() {Serial.begin(9600); // initialize serial communication at 9600 bits per secondesp8266.begin(9600); ////begin the software serial communication with a baud rate of 9600analogWriteResolution(10);sendAT('AT+RST', 2000, DEBUG); // call sendAT function to send reset AT commandsendAT('AT', 1000, DEBUG);sendAT('AT+CWMODE=1', 1000, DEBUG); //call sendAT function to set ESP8266 to station modesendAT('AT+CWJAP=''SSID'',''PASS''', 2000, DEBUG); //AT command to connect with the Wi-Fi network    while(!esp8266.find('OK')) { //wait for connection  }  sendAT('AT+CIFSR', 1000, DEBUG); //AT command to print IP address on serial monitor  sendAT('AT+CIPMUX=0', 1000, DEBUG); //AT command to set ESP8266 to multiple connections}// the loop routine runs repeatedly forever:      void loop() {     // read the input on analog pin 0:     int val = analogRead(batteryPin);     analogWrite(DAC0, 300);     analogWrite(DAC1, 800);     // print out the value you read:    float volts = (val / 1023.0) * referenceVolts;    Serial.println(volts);    delay(100);        // delay in between reads for stability    }void updateTS(String T,String P){  Serial.println('');  sendAT('AT+CIPSTART='TCP','api.thingspeak.com',80', 1000, DEBUG);  delay(2000);  String cmdlen;  String cmd='GET /update?key=KX9IF911J8PEBEMU&field1='+T+'&field2='+P+''; // update the voltage values on thingspeak URL   cmdlen = cmd.length();  sendAT('AT+CIPSEND='+cmdlen+'', 2000, DEBUG);   esp8266.print(cmd);   Serial.println('');   sendAT('AT+CIPCLOSE', 2000, DEBUG);   Serial.println('');   delay(15000);   }", "num_user_post": " 1", "author": "yohannes"}]}, {"url": "https://community.thingspeak.com/forum/arduino/about-thingspeak-read-and-write-delay-problem/", "posts": [{"date": "July 3, 2018 - 6:03 am", "content": "Hello,I have a question about the delay of reading or writing on THINGSPEAK.The code is about turning on the LED by reading the value on THINGSPEAK. After 10 seconds, the LED is turned off, but it takes about 5 seconds to read the value on the thingspeak, and then the value on the thingspeak is also rewritten also took 5 seconds.Is this delay normal? Because the official indication is that the transmission time is 1 second.Here is my code********************************#include#include#include //Replace your wifi credentials hereconst char* ssid = 'xxxxxxxxxxxxxxxx';const char* password = 'xxxxxxxxxxxxxxxxxx'; //change your channel number hereunsigned long myChannelNumber =xxxxxxxxxxxx;const char * myWriteAPIKey = 'xxxxxxxxxxxxxxxxxx';WiFiClient client;  void setup() {  Serial.begin(115200);  delay(100);  pinMode (D1, OUTPUT);  digitalWrite(D1, LOW);  // We start by connecting to a WiFi network  Serial.println();  Serial.println();  Serial.print('Connecting to ');  Serial.println(ssid);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) {    delay(500);    Serial.print('.');  }  Serial.println('');  Serial.println('WiFi connected');  Serial.println('IP address: ');  Serial.println(WiFi.localIP());  Serial.print('Netmask: ');  Serial.println(WiFi.subnetMask());  Serial.print('Gateway: ');  Serial.println(WiFi.gatewayIP());  ThingSpeak.begin(client);}void loop() {  //get the last data of the fieldsbool led_1 = ThingSpeak.readFloatField(myChannelNumber,1,myWriteAPIKey); Serial.print('led1='); Serial.println(led_1);if(led_1 == 1){digitalWrite(D1,HIGH);Serial.println('D1 is On..!');delay(10000);      //delay 10secThingSpeak.writeField(myChannelNumber, 1, 0,myWriteAPIKey);}if(led_1==0){  digitalWrite(D1,LOW);}}", "num_user_post": " 2", "author": "pantani"}, {"date": "July 3, 2018 - 8:57 am", "content": "If you are using a free user account, you are limited to updates only every 15 seconds.  Your code would violate that limit every other time through the loop.Also, you have a mandated delay in the loop before the channel read is performed.  See the examples in the ThingSpeak documentation for a more efficient solution. For example,https://www.mathworks.com/help/thingspeak/rapid-prototyping-with-thingspeak.htmlin section d, you can see how the time is checked (millis() )each time through the loop and then a post happens only when the appropriate time has elapsed.You can put the read request in a loop with a smaller timeout.  Then you will have faster response for your reads and the writes wont be too fast.The connection delays will depend on your local environment more than ThingSpeak response time.  5 seconds is longer than I would expect, assuming you are not violating the update rate. But the 5 seconds or longer makes sense with the code above.Another, solution is to use MQTT subscribe.  The performance will likely be a good deal faster since the broker will push updates to the device every time the channel is updated.  I have acheived 100-200 ms with MQTT subscribe on a device (faster with a desktop subscription program)Here is particle photon code for subscribe, it is similar to arduino:https://www.mathworks.com/help/thingspeak/use-particle-photon-client-to-subscribe-to-channel-updates.htmlHere is publish code for srduino, you can use the same connection methods and then use the subscribe parts from the photon example.https://www.mathworks.com/help/thingspeak/use-arduino-client-to-publish-to-a-channel.htmland here is the MQTT doc:https://www.mathworks.com/help/thingspeak/mqtt-api.html", "num_user_post": " 401", "author": "cstapels"}, {"date": "July 4, 2018 - 4:19 am", "content": "Thanks for cstapels reply.I am using  home license , so the update limit is 1 second. Now I try to use millis() to modify and measure the time of reading time interval .The time is  still about 5~6 seconds.As you said, my code will cause a long delay. How do I change the code to reduce this delay?Below is the modified code,#include#include#include unsigned long deltaInterval;unsigned long time1;unsigned long time2;//Replace your wifi credentials hereconst char* ssid = 'xxxxxx';const char* password = 'xxxxxxx';//change your channel number hereunsigned long myChannelNumber =xxxxxxx;const char * myWriteAPIKey = 'xxxxxxxxxx';WiFiClient client;  void setup() {  Serial.begin(115200);  delay(100);  Serial.println();  Serial.println();  Serial.print('Connecting to ');  Serial.println(ssid);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) {    delay(500);    Serial.print('.');  }  ThingSpeak.begin(client);}void loop() {      time1=millis();      bool led_1 = ThingSpeak.readFloatField(myChannelNumber,1,myWriteAPIKey);      time2=millis();      deltaInterval=time2-time1;      Serial.print('deltaInterval=');      Serial. println(deltaInterval);      Serial.print('led1=');      Serial.println(led_1);}****************Result**************************deltaInterval=5724led1=0deltaInterval=5948led1=0deltaInterval=6040led1=0deltaInterval=5810led1=0deltaInterval=5866led1=1deltaInterval=5826led1=1deltaInterval=5948...**********************************************", "num_user_post": " 2", "author": "pantani"}, {"date": "July 6, 2018 - 3:34 pm", "content": "Have a look at the examples I listed above.  They show a way to make a more efficient loop using the timer to check the elapsed time.  Did you see the code in section d for the proximity sensor?", "num_user_post": " 401", "author": "cstapels"}]}, {"url": "https://community.thingspeak.com/forum/arduino/connect-arduino-to-internet-through-usb-cable-very-simple-question/", "posts": [{"date": "July 3, 2018 - 6:07 pm", "content": "I am extremely new beginner to this and I have been using my arduino by just keeping it plugged into my computer through the USB to keep it powered and run my sketches. I just signed up for ThingSpeak and am trying to get started and I was wondering if it is possible to use ThingSpeak by keeping my arduino plugged into my computer (which has WiFi) through the USB. I do not have an ethernet/wifi shield and this is why I am wondering if I can do it this way; it seems like it should work because my computer is hooked to wifi and my arduino is physically attached to my computer.(reasoning: Since this is new to me I want to try to figure things out/understand before I invest more money into it.)", "num_user_post": " 2", "author": "AnnaLB"}, {"date": "July 4, 2018 - 3:55 pm", "content": "I think I may have figured my problem out, it was not as simple as I suspected, so if anyone has an easier way to do this I would love to learn! Posting this as a comment in case anyone else has the same issue.My solution was to use python as a middle man between the arduino and thingspeak using the serial monitor and pySerial package. If you're more of a java person I was also able to get it to work using processing (processing.org) as a middle man as well.Here is a helpful video I found using python: ", "num_user_post": " 2", "author": "AnnaLB"}, {"date": "July 6, 2018 - 2:04 pm", "content": "That is a very creative solution, thanks for your post.I would consider purchasing an esp8266, such as a NODEMCU or similar.  They cost less than the arduino and include WiFi capability.  The ESP32 has even more advanced capabilities. (bluetooth etc)", "num_user_post": " 401", "author": "cstapels"}]}, {"url": "https://community.thingspeak.com/forum/arduino/testing-bulk-update-feature-with-arduino-mkr-gsm/", "posts": [{"date": "April 13, 2018 - 4:35 pm", "content": "Hello.I have been testing the bulk update feature using Arduino MKR 1400 GSM and I have experimented some problems. For some strange reason, I only can send bulk updates when the packet size is about 256 bytes or less, but not longer. Every time I send my packet with size longer than 256 bytes, I receive an error. I don't know if this error is caused by the library (MKRGSM) or is a limitation on the GSM chip. This supposes a very serious inconvenience for me, because I need to send about 180 measurements (2,2Kbytes); and the between consecutive bulk updates must be 15 seconds or more.Can someone tell me what could be the reason of this limitation?This is my arduino code. (For requests with packet size of 256 bytes works fine, but with longer size not).#####################################################\u00a0// include the GSM library #include// PIN number if necessary #define PINNUMBER ''// APN information obrained from your network provider #define GPRS_APN '?????????' // replace with your GPRS APN #define GPRS_LOGIN '' // replace with your GPRS login #define GPRS_PASSWORD '' // replace with your GPRS password// initialize the library instances GSMClient client; GPRS gprs; GSM gsmAccess(true);\u00a0// ThingSpeak Settings char thingSpeakAddress[] = 'api.thingspeak.com'; String writeAPIKey = 'MY_API_KEY_WR'; //replace with your API Key const int updateThingSpeakInterval = 15 * 1000; // Time interval in milliseconds to update ThingSpeak (number of seconds * 1000 = interval)// Variable Setup long lastConnectionTime = 0; boolean lastConnected = false; int failedCounter = 0;char superstring[] = '{'write_api_key':'MY_API_KEY_WR','updates':[{'delta_t':0,'field8':-1000000},{'delta_t':1,'field8':-1000000},{'delta_t':1,'field8':-1000000},{'delta_t':1,'field8':-1000000},{'delta_t':1,'field8':-1000000},{'delta_t':1,'field8':-1000000},{'delta_t':1,'field8':-9999999},{'delta_t':1,'field8':-1000000},{'delta_t':1,'field8':-9999999}]}';\u00a0void setup() { Serial.setTimeout(5); Serial.begin(57600); // opens serial port, sets data rate to 9600 bps StartGSM(); }\u00a0void loop() { if (client.available()) { char c = client.read(); Serial.print(c); }// Disconnect from ThingSpeak if (!client.connected() && lastConnected){ Serial.println('...disconnected'); Serial.println();client.stop(); }// Update ThingSpeak if(!client.connected() && (millis() - lastConnectionTime > updateThingSpeakInterval)) { String ToThingSpeak = superstring; Serial.println(ToThingSpeak); updateThingSpeak(ToThingSpeak); }if (failedCounter > 3 ) { StartGSM(); }lastConnected = client.connected(); }void updateThingSpeak(String tsData) { if (client.connect(thingSpeakAddress, 80)) { Serial.println('[-] Enviando datos !!!! '); client.println('POST /channels/MY_CHANNEL/bulk_update.json HTTP/1.1'); client.println('Host: api.thingspeak.com'); client.println('User-Agent: mw.doc.bulk-update (Arduino ESP8266)'); client.println('Connection: close'); client.println('Content-Type: application/json'); client.print('Content-Length: '); client.print(tsData.length()); client.print('');client.print(tsData);lastConnectionTime = millis();if (client.connected()) { Serial.println('Connecting to ThingSpeak...'); Serial.println();failedCounter = 0; } else { failedCounter++;Serial.println('Connection to ThingSpeak failed ('+String(failedCounter, DEC)+')'); Serial.println(); }} else { failedCounter++;Serial.println('Connection to ThingSpeak Failed ('+String(failedCounter, DEC)+')'); Serial.println();lastConnectionTime = millis(); } }void StartGSM() { char server[] = 'api.thingspeak.com'; // the base URL int port = 80; // the port, 80 for HTTPSerial.println('Starting Arduino web client.'); // connection state boolean notConnected = true;// Start GSM shield // pass the PIN of your SIM as a parameter of gsmAccess.begin() while(notConnected) { if((gsmAccess.begin(PINNUMBER)==GSM_READY) & (gprs.attachGPRS(GPRS_APN, GPRS_LOGIN, GPRS_PASSWORD)==GPRS_READY)) { notConnected = false; } else { Serial.println('Not connected'); delay(1000); } }Serial.println('connecting...');// if you get a connection, report back via serial: if (client.connect(server, port)) { Serial.println('connected'); } else { // if you didn't get a connection to the server: Serial.println('connection failed'); }}################################################\u00a0Thank you Best regards", "num_user_post": " 16", "author": "eplantes"}, {"date": "April 15, 2018 - 10:28 pm", "content": "I have run into buffer size limitations with Arduino for HTTP posts.\u00a0 Instead of building \u2018superstring \u2018 in advance, I would store your field data in an array and pass the array to your posting function.\u00a0 Then send one field at a time so you don\u2019t have a big string.\u00a0\u201cclient.println('Content-Type: application/json'); client.print('Content-Length: '); client.print(tsData.length()); client.print('\u201d\u2026\u00a0client.print(\u201c&field1=\u201d+String(fieldArray[1]);client.print(\u201c&field2=\u201d+String(fieldArray[2]);client.print(\u201c&field3=\u201d+String(fieldArray[3]);client.print(\u201c&field4=\u201d+String(fieldArray[4]);client.println();\u2026and so on.\u00a0 You can obviously use a loop here.", "num_user_post": " 401", "author": "cstapels"}, {"date": "April 16, 2018 - 8:21 am", "content": "Hello cstapels.Thanks for your response but\u00a0I have a doubt. According to the documentation, the time between consecutive bulk updates must be 15 seconds or more. So if I have to send 180 measurenments, I need a lot of time to send all data. In my case I don't need to send eight flieds every time, only 1 field; for this reason I thought creating a superstring it would be the best option.\u00a0On another hand, looking at the MKRGSM library I have noticed in the GSMClient.cpp file, in the write method, that the max size packet is 256. I suposse it must be some reason of that, so I'm not sure if is not possible increase it. This could be the cause of my problem.This is the part of the code affected:**************************************size_t GSMClient::write(const uint8_t* buf, size_t size){\u00a0 if (_writeSync) {\u00a0 \u00a0 while (ready() == 0);\u00a0 } else if (ready() == 0) {\u00a0 \u00a0 return 0;\u00a0 }\u00a0 if (_socket == -1) {\u00a0 \u00a0 return 0;\u00a0 }\u00a0 size_t written = 0;\u00a0 String command;\u00a0 while (size) {\u00a0 \u00a0 size_t chunkSize = size;\u00a0 \u00a0 if (chunkSize > 256) { # <----------------------------------------------------------- !!!!\u00a0 \u00a0 \u00a0 chunkSize = 256;\u00a0 \u00a0 }\u00a0 \u00a0 command.reserve(19 + chunkSize * 2);\u00a0 \u00a0 command += 'AT+USOWR=';\u00a0 \u00a0 command += _socket;\u00a0 \u00a0 command += ',';\u00a0 \u00a0 command += chunkSize;\u00a0 \u00a0 command += ','';\u00a0 \u00a0 for (size_t i = 0; i < chunkSize; i++) {\u00a0 \u00a0 \u00a0 byte b = buf[i + written];\u00a0 \u00a0 \u00a0 byte n1 = (b >> 4) & 0x0f;\u00a0 \u00a0 \u00a0 byte n2 = (b & 0x0f);\u00a0 \u00a0 \u00a0 command += (char)(n1 > 9 ? 'A' + n1 - 10 : '0' + n1);\u00a0 \u00a0 \u00a0 command += (char)(n2 > 9 ? 'A' + n2 - 10 : '0' + n2);\u00a0 \u00a0 }\u00a0 \u00a0 command += ''';\u00a0 \u00a0 MODEM.send(command);\u00a0 \u00a0 if (_writeSync) {\u00a0 \u00a0 \u00a0 if (MODEM.waitForResponse(10000) != 1) {\u00a0 \u00a0 \u00a0 \u00a0 break;\u00a0 \u00a0 \u00a0 }\u00a0 \u00a0 }\u00a0 \u00a0 written += chunkSize;\u00a0 \u00a0 size -= chunkSize;\u00a0 }\u00a0 return written;}\u00a0******************************thank you", "num_user_post": " 16", "author": "eplantes"}, {"date": "April 16, 2018 - 11:09 am", "content": "I think you have got the problem figured out now.\u00a0 You don't need to increase the buffer size though,\u00a0 Just send each measurement separately.It the same thing for one field.\u00a0\u00a0Send an array of measurements and times to your posting functions. Then you will never exceed the 256 byte limit. Here is pseudo code, I have not checked all the syntax- you really have to be careful with all the quotes and slashes:int deltaTs[measurements];float values[measurements];posting_function(deltaTs,values){..headers and other stuff...client.print('{'write_api_key':'+String(MY_API_KEY_WR);client.print('','updates':[');for (int i=0;i<measurements;i++){client.print('{'delta_t':'+String(deltaTs[i])+','field8':-'+String(values[i])+'},');}}", "num_user_post": " 401", "author": "cstapels"}, {"date": "April 16, 2018 - 11:49 am", "content": "Thanks Cstapels.I'm going to test it!!Thank you very much.", "num_user_post": " 16", "author": "eplantes"}, {"date": "April 16, 2018 - 2:01 pm", "content": "Hei Cstapels!I've tested it and it works!!At the moment I can't send all data al the same time, I don't know the reason, but I can send over 80\u00a0measurements\u00a0every time. This is fantastic for me, because I can send all data in three requests. I just need to wait the precise time between requests. Once I've finished my code and I've tested it, I'll post it in this thread; maybe it can be\u00a0useful\u00a0for someone.Thank you very much!", "num_user_post": " 16", "author": "eplantes"}, {"date": "April 20, 2018 - 5:48 pm", "content": "Great news!  Definitely post your finished code.  And please share the final results of your project too if you can.", "num_user_post": " 401", "author": "cstapels"}, {"date": "June 22, 2018 - 6:10 am", "content": "Hello.Once I have done a lot of tests (about 4000 requests or more) I think my program is very stable, so I would like to share my code with the community. First of all my program starts a monitoring process during 150 seconds, where it reads some parameters like electrical conductivity, temperature, humidity, etc.. when this process has finished, it calls to bulkUpdate methods to send these values to ThingSpeak platform. Once the program finished, it goes to sleep mode.##########################################################################################// Arduino Libraries#include#include#include#include 'DHT.h'#include#include#include//#include #include // GSM dataconst char  GPRS_APN[]      = SECRET_GPRS_APN;const char  GPRS_LOGIN[]    = SECRET_GPRS_LOGIN;const char  GPRS_PASSWORD[] = SECRET_GPRS_PASSWORD;const char  PINNUMBER[]     = SECRET_PIN;boolean     connected       = false;byte        failedCounter   = 0;// GSM ClassesGSMClient client;GPRS gprs;GSM gsmAccess;// ThingSpeak Settingsconst char  server[]         = 'api.thingspeak.com';const byte  port             = 80;const char  API_KEY[]        = SECRET_API_KEY;const char  CHANNEL[]        = SECRET_CHANNEL;// Leds, DHT#define POWER_ON      2#define K1            3#define K2            4#define DHTPIN        5#define DHTTYPE       DHT11// Analog inputs#define PSOLAR_INPUT  A1#define BAT_INPUT     A2// DHT Temp humDHT dht(DHTPIN, DHTTYPE);float lectura;float temp;float hum;float tbulbo;float volSolar;float volBat;// CDA 16 bits ADS1115Adafruit_ADS1115 ads(0x48);int16_t adc0, adc1, adc2, adc3;static char vol[10];// Timers and injections controllersconst byte NMUESTRAS            = 75;const unsigned long __TIMEOUT__ = 10 * 1000;const int TIME_SLEEP            = 5 *  60 * 1000; // 12 * 60 * 1000;unsigned long time_read         = 0;byte countReads                 = 0;byte indexPot                   = 0;// Control injections variablesstatic boolean toSleep             = false;static boolean injectionFinished   = false;static boolean initProcess         = true;static boolean posCycle            = true;static int     counterCycles       = 1;const  int     MAX_CYCLES          = 96;// Vector de potenciales electricosfloat potenciales[NMUESTRAS];/** * /////////////////////////////////////////////////////////////// *  reboot Method *  Reinicia el dispositivo * ////////////////////////////////////////////////////////////// **/void reboot(){  NVIC_SystemReset();}/** * /////////////////////////////////////////////////////////////// *  Setup Method *  Se inicializa todos los parametros del dispositivo * ////////////////////////////////////////////////////////////// **/void setup() {  //Serial.setTimeout(5);  Serial.begin(9600);  Serial.println('[INIT] Iniciando dispositivo .... ');  //Init digital relays outputs  pinMode(DHTPIN, INPUT);  pinMode(K1, OUTPUT);  pinMode(K2, OUTPUT);  pinMode(POWER_ON, OUTPUT);  // Init DHT AD conversor  dht.begin();  ads.begin();  //Init process  connectedGSM();  initProcess = true;}void loop() {  mainProcess();  Serial.println('[FINISHED] Proceso terminado. Dispositivo en modo SLEEP ....');  LowPower.sleep(TIME_SLEEP);}/** * /////////////////////////////////////////////////////////////// *  - mainProcess *  Proceso general del programa *  - Obtiene 75 lecturas *  - Envia valores calculados *  - El dispositivo entra en modo SLEEP * ////////////////////////////////////////////////////////////// **/void mainProcess() {  while (!toSleep) {    if (!injectionFinished) {      if (initProcess) {        initProcess = false;        injectionFinished = false;        initCycle();      }      if (!injectionFinished) {        if (millis() - time_read >= 2000) {          readData();          time_read = millis();        }      }    } else {      Serial.println('[INFO] Inyeccion finalizada mostrando datos ....');       // Finalizar ciclo posito/negativo      // Lectura parametros: Temperatura, humedad, Vbat ...      finishCycle();      calculateFinalValues();      //Conexion GSM y envio de datos      digitalWrite(POWER_ON, LOW);      bulkUpdate(0, 75);      toSleep = true;      initProcess = true;    }  }  injectionFinished = false;  toSleep = false;}/** * /////////////////////////////////////////////////////////////// *  - readData *  Realiza una lectura * ////////////////////////////////////////////////////////////// **/void readData() {  adc0 = ads.readADC_SingleEnded(0);  adc1 = ads.readADC_SingleEnded(1);  adc2 = ads.readADC_SingleEnded(2);  adc3 = ads.readADC_SingleEnded(3);  lectura = (adc0 * 0.1875);  countReads++;  if (!posCycle) {    lectura = lectura * -1;  }  Serial.print('[INFO] Sonda Pot: ');  Serial.println(lectura, 3);  potenciales[indexPot] = lectura;  indexPot++;  if (countReads >= NMUESTRAS) {    injectionFinished = true;  }}/** * /////////////////////////////////////////////////////////////// *  - getLastString *  Recupera los valores almacenados en el proceso, y prepara la *  ultima cadena a enviar a la plataforma ThingSpeak * ////////////////////////////////////////////////////////////// **/String getLastString() {  String StringToThingSpeak =',{'delta_t':1,'field1':' + String(0)                             + ','field2':' + String(counterCycles)                             + ','field3':' + String(potenciales[NMUESTRAS - 1], 3)                             + ','field4':' + String(tbulbo, 1)                             + ','field5':' + String(temp)                             + ','field6':' + String(hum)                             + ','field7':' + String(volBat)                             + ','field8':' + String(volSolar)                             + '}';  Serial.print('[-] Ultima cadena a enviar: ');  Serial.println(StringToThingSpeak);  return StringToThingSpeak;}/** * /////////////////////////////////////////////////////////////// *  - Iniciar ciclo positivo/negativo * ////////////////////////////////////////////////////////////// **/void initCycle() {  Serial.println('[INFO] Iniciando CICLO .... ');  digitalWrite(POWER_ON, HIGH);  delay(2000);  if (posCycle && digitalRead(K2) == LOW) {    digitalWrite(K1, HIGH);    Serial.println('[+] Proceso de ciclo positivo.');  } else if (!posCycle && digitalRead(K1) == LOW){    digitalWrite(K2, HIGH);    Serial.println('[-] Proceso de ciclo negativo.');  }  // Iniciar contadores  countReads  = 0;  indexPot    = 0;  failedCounter = 0;  // Iniciar temporizadores  time_read = millis();}/** * /////////////////////////////////////////////////////////////// *  - Finalizar ciclo positivo/negativo * ////////////////////////////////////////////////////////////// **/void finishCycle() {  if (digitalRead(K1) == HIGH) {    digitalWrite(K1, LOW);    posCycle = false;    Serial.println('[+] Finaliza ciclo positivo.');  } else if (digitalRead(K2) == HIGH) {    digitalWrite(K2, LOW);    posCycle = true;    Serial.print('[-] Finaliza de ciclo negativo.');  }  time_read = 0;}/** * ////////////////////////////////////////////////////////////// * bulkUpdate * ////////////////////////////////////////////////////////////// **/void bulkUpdate(int indexIni, int IndexFin) {  int ldata = getlengthData(indexIni, IndexFin);  String potencial = '';  client.stop();  if (client.connect(server, port)) {    Serial.println('[-] Enviando datos !!!! ');    client.println('POST /channels/' + String(CHANNEL)+'/bulk_update.json HTTP/1.1');    client.println('Host: api.thingspeak.com');    client.println('User-Agent: Arduino MKRGSM');    client.println('Connection: close');    client.println('Content-Type: application/json');    client.print('Content-Length: ');    client.print(ldata);    Serial.print('[>] Longitud cadena: ');    Serial.println(ldata);    client.print('');    potencial = String(potenciales[indexIni], 3);    client.print('{'write_api_key':'' + String(API_KEY) +'','updates':[{'delta_t':0,'field3':' + potencial + '}');    for (int i = indexIni +1 ; i < IndexFin-1; i++){      potencial = String(potenciales[i], 3);      client.print(',{'delta_t':2,'field3':' + potencial + '}');    }    client.print(getLastString());    client.print(']}');    //Comprobacion codigo respuesta servidor    delay(250);    String rs = 'Respuesta bulkUpdate: ';    client.parseFloat();    rs += String(client.parseInt());    Serial.println(rs);  } else {    failedCounter++;    Serial.println('Connection to ThingSpeak Failed ('+String(failedCounter, DEC)+')');    Serial.println();  }}/** * /////////////////////////////////////////////////////////////// *   Gestiona la conexion GSM usando los parametros configurados *   en el fichero secrets: PIN, APN, user, password * ////////////////////////////////////////////////////////////// **/bool connectedGSM() {  Serial.println('[INFO] Starting Arduino web client.');  // connection state  //boolean connected = false;  while (!connected) {   if ((gsmAccess.begin(PINNUMBER)) == GSM_READY) {        if (gprs.attachGPRS(GPRS_APN, GPRS_LOGIN, GPRS_PASSWORD) == GPRS_READY) {          connected = true;          Serial.println('[OK] Connected APN settings succesful');        }    } else {      Serial.println('[FAIL] Not connected to GSM... Trying again!');      delay(1000);    }  } return connected;}int getlengthData(int indexIni, int indexFi) {  int size = 0;  String val = String(potenciales[0], 3);  size += String('{'write_api_key':'').length();  size += String(API_KEY).length();  size += String('','updates':[{'delta_t':0,'field3':').length();  size += String(val).length();  size += String('}').length();  for (int i = indexIni+1; i < indexFi-1; i++){    size += String(',{'delta_t':2,'field3':').length();    val = String(potenciales[i], 3);    size += String(val).length();    size += String('}').length();  }  // Finalizaci\u00f3n de la cadena  size += String(getLastString()).length();  size += String(']}').length();  Serial.print('[INFO] Longitud calculada: ');  Serial.println(size);  return size;}/** * ////////////////////////////////////////////////////////////// * Obtiene el voltaje de la bateria * ////////////////////////////////////////////////////////////// **/void getLevelBattery(){  int sensorValue = analogRead(ADC_BATTERY);  // Convert the analog reading (which goes from 0 - 1023)  // to a voltage (0 - 4.3V):  volBat = sensorValue * (4.3 / 1023.0);}/** * ////////////////////////////////////////////////////////////// * Calcula la temperatura y humedad exterior * a partir de la sonda DHT11 * ////////////////////////////////////////////////////////////// **/void calculateTempHum() {  //Temperatura bulbo  int16_t adc1 = ads.readADC_SingleEnded(1);  tbulbo = (adc1 * 0.1875) / 10.0 ;  //Temperatura y humedad exterior  hum = dht.readHumidity();  temp = dht.readTemperature();  if (isnan(hum) || isnan(temp)) {    Serial.println('Failed to read from DHT sensor!');    temp = 99;    hum = 99;    return;  }}/** * /////////////////////////////////////////////////////////////// *  - getVolPanelSolar *  Calcula el voltaje del panel solar * ////////////////////////////////////////////////////////////// **/void getVolPanelSolar() {  int sensor = analogRead(PSOLAR_INPUT);  volSolar = sensor * (5 / 1024.0);}/** * /////////////////////////////////////////////////////////////// *  - calculateFinalValues *  Calcula los valores finales y los imprime por pantalla * ////////////////////////////////////////////////////////////// **/void calculateFinalValues() {  calculateTempHum();  getVolPanelSolar();  getLevelBattery();  printResults();}/** * /////////////////////////////////////////////////////////////// *  - printResults *  Muestra lo valores finales calculados. * ////////////////////////////////////////////////////////////// **/String printResults() {  Serial.println('[-] Valores calculados finales');  Serial.print('t- Field 1: '); Serial.println(String(0));  Serial.print('t- Contador: '); Serial.println(counterCycles);  Serial.print('t- Voltaje Panel solar: '); Serial.println(volSolar);  Serial.print('t- Temp exterior: '); Serial.println(temp);  Serial.print('t- Hum  exterior: '); Serial.println(hum);  Serial.print('t- Temp bulbo: '); Serial.println(tbulbo);  Serial.print('t- Voltaje bateria: '); Serial.println(volBat);}###########################################################Thanks", "num_user_post": " 16", "author": "eplantes"}]}, {"url": "https://community.thingspeak.com/forum/arduino/sending-dht11-data-through-ethernet-shield-on-thingspeak/", "posts": [{"date": "April 16, 2018 - 10:57 pm", "content": "I am trying to send DHT11 data through Ethernet Shield W5100 on thingspeak. But my code's output is -999 for both temperature and humidity.It also shows -999 on serial monitor of Arduino IDE and also on thingspeak.Please help if someone knows the error in the code#include <SPI.h>#include <Ethernet.h>#include <dht.h>#define DHT11PIN A0#define DHTTYPE DHT11dht DHT11; // OK\u00a0// Local Network Settingsbyte mac[] = { 0xD4, 0xA8, 0xE2, 0xFE, 0xA0, 0xA1 }; // Must be unique on local networkbyte ip[] = {192,168,0,150 }; // Must be unique on local networkbyte gateway[] = {192,168,0,1 };byte subnet[] = { 255, 255, 255, 0 };// ThingSpeak Settingschar thingSpeakAddress[] = 'api.thingspeak.com';String writeAPIKey = '1OU6VU71STLR'; // Write API Key for a ThingSpeak Channelconst int updateInterval =16*1000; // Time interval in milliseconds to update ThingSpeak// Variable Setuplong lastConnectionTime = 0;boolean lastConnected = false;int failedCounter = 0;// Initialize Arduino Ethernet ClientEthernetClient client;void setup(){Serial.begin(115200); Ethernet.begin(mac, ip, gateway, subnet); delay(1000); Serial.print('ETHERNET SHIELD ip is : '); Serial.println(Ethernet.localIP()); // Start Ethernet on Arduino startEthernet();}void loop(){ String analogPin0 = String(analogRead(A0), DEC); //OK // Print Update Response to Serial Monitor if (client.available()) { char c = client.read(); Serial.print(c); }int chk=DHT11.read(DHT11PIN);char t_buffer[10];char h_buffer[10];float t=(DHT11.temperature);String temp=dtostrf(t,0,5,t_buffer);Serial.print(temp);Serial.print(' ');float h=(DHT11.humidity);String humid=dtostrf(h,0,5,h_buffer);Serial.print(humid);\u00a0// Disconnect from ThingSpeak if (!client.connected() && lastConnected) { Serial.println(); Serial.println('...disconnected.'); Serial.println(); client.stop(); } // Update ThingSpeak if(!client.connected() && (millis() - lastConnectionTime > updateInterval)) { updateThingSpeak('field1='+temp+'&field2='+humid); } lastConnected = client.connected();}void updateThingSpeak(String tsData){ if (client.connect(thingSpeakAddress, 80)) { client.print('POST /update HTTP/1.1'); client.print('Host: api.thingspeak.com'); client.print('Connection: close'); client.print('X-THINGSPEAKAPIKEY: '+writeAPIKey+''); client.print('Content-Type: application/x-www-form-urlencoded'); client.print('Content-Length: '); client.print(tsData.length()); client.print('');client.print(tsData); lastConnectionTime = millis(); if (client.connected()) { Serial.println('Connecting to ThingSpeak...'); Serial.println(); failedCounter = 0; } else { failedCounter++; Serial.println('Connection to ThingSpeak failed ('+String(failedCounter, DEC)+')'); Serial.println(); } } else { failedCounter++; Serial.println('Connection to ThingSpeak Failed ('+String(failedCounter, DEC)+')'); Serial.println(); lastConnectionTime = millis(); }}void startEthernet(){ client.stop();Serial.println('Connecting Arduino to network...'); Serial.println();delay(1000); // Connect to network amd obtain an IP address using DHCP if (Ethernet.begin(mac) == 0) { Serial.println('DHCP Failed, reset Arduino to try again'); Serial.println(); } else { Serial.println('Arduino connected to network using DHCP'); Serial.println(); Serial.println('Data being uploaded to THINGSPEAK Server.......'); Serial.println(); } delay(1000);}", "num_user_post": " 1", "author": "Syed_Tauqeer"}, {"date": "May 1, 2018 - 3:37 pm", "content": "If the value is wrong on the serial monitor, its more likely a setup issue, connection issue, or library issue.  I would simplify your example, and just get the dht output on the serial monitor working.  There is probably a simple example that comes with the library you are using.", "num_user_post": " 401", "author": "cstapels"}]}, {"url": "https://community.thingspeak.com/forum/arduino/problems-sending-data-with-arduino-mkr1400-gsm-and-mqtt/", "posts": [{"date": "April 12, 2018 - 11:38 am", "content": "Hello.Once the purchase of the commercial license has been made, we have begun to carry out the first tests with unexpected results.Our sensor network is made up of Arduino MKR 1400 GSM type devices. The fact of choosing as a means of GSM transmission and not Wifi is simple. As the crops are far from urbanization and the distances between crops can be considerable, (because they are in the middle of the field), we did not want them to depend on a Wifi network or the need to put repeaters due to the coverage. In that sense, GSM technology, although old, seemed the best option.However, the choice of this has certain limitations. Due to the large number of samples that have to be sent during each cycle (1 per second, 3 minutes, total 180 samples), we have used the MQTT protocol for the implementation of the sample shipment. From what I understand, this protocol being light, is the most appropriate to send data in real time. Therefore our arduino program establishes a first connection with the server, and once established, it starts sending data once per second for three minutes.However, due to the graphics obtained in our channels, the results are not as expected. Of 180 samples, about 130 are received more or less, the rest seems to be lost. To others, when downloading the data of the channel we see that many of them arrive with several seconds of difference, instead of a second that is as it should be.It gives the sensation that the packages do not arrive by what is the own means of transmission. The problem is that we need these 180 samples to do later an optimization calculation of non-linear functions in Matlab. Doing it at the device level (at the Arduino level), would bring many complications, such as accuracy, calculation capacity and processing speed.I understand that the solution is not simple. Nevertheless I am waiting for your comments.This is my arduino program#####################################// This example uses an Arduino MKR GSM 1400 board// to connect to shiftr.io.//// IMPORTANT: This example uses the new MKRGSM library.//// You can check on your device after a successful// connection here: https://shiftr.io/try.//// by Sandeep Mistry// https://github.com/256dpi/arduino-mqtt#include <MKRGSM.h>#include <MQTT.h>#include <ArduinoLowPower.h>const char pin[] = 'NULL';const char apn[] = 'MY_APN';const char login[] = 'NULL';const char password[] = 'NULL';const char* serverMQTT = 'mqtt.thingspeak.com';unsigned long lastConnectionTime = 0;char mqttUserName[] = 'GSM1'; // Can be any name.char mqttPass[] = '######MYPASS######'; // Change this your MQTT API Key from Account > MyProfile.char writeAPIKey[] = '########MYWRAPIKEY########'; // Change to your channel Write API Key.long channelID = MYCHANNEL;static const char alphanum[] ='0123456789' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'; // For random generation of client ID.\u00a0GSMSSLClient net;GPRS gprs;GSM gsmAccess;MQTTClient client;unsigned long lastMillis = 0;static bool toSleep = false;int counter = 0;const int TIME_SLEEP = 15 * 60 * 1000; // 15 * 60 * 1000void connect() { // connection state bool connected = false; char clientID[10];Serial.print('connecting to cellular network ...');// After starting the modem with gsmAccess.begin() // attach to the GPRS network with the APN, login and password while (!connected) {\u00a0 if ((gsmAccess.begin(pin) == GSM_READY) &&\u00a0 \u00a0 (gprs.attachGPRS(apn, login, password) == GPRS_READY)) {\u00a0 \u00a0 connected = true;\u00a0} else {\u00a0 \u00a0Serial.print('.');\u00a0 \u00a0delay(1000);\u00a0}\u00a0} Serial.print('Attempting MQTT connection...'); // Generate ClientID\u00a0for (int i = 0; i < 8; i++) {\u00a0 \u00a0clientID[i] = alphanum[random(51)];\u00a0} Serial.print(' Conectando al servidor Mqtt...'); while (!client.connect(clientID, mqttUserName, mqttPass)) { Serial.print('.'); delay(5000);}\u00a0Serial.println('connected!');\u00a0//client.subscribe('/hello');\u00a0// client.unsubscribe('/hello');}void messageReceived(String &topic, String &payload) {\u00a0 Serial.println('incoming: ' + topic + ' - ' + payload);}void setup() {\u00a0 Serial.begin(115200);\u00a0 // Note: Local domain names (e.g. 'Computer.local' on OSX) are not supported by Arduino.\u00a0 // You need to set the IP address directly.\u00a0 client.begin(serverMQTT, 8883, net);\u00a0 client.onMessage(messageReceived);\u00a0 connect();}void loop() {\u00a0 client.loop();\u00a0 if (!client.connected()) {\u00a0 \u00a0 connect();\u00a0 }\u00a0 // publish a message roughly every second.\u00a0 if (millis() - lastMillis >= 1000) {\u00a0 \u00a0 \u00a0mqttpublishSingle();\u00a0 \u00a0 \u00a0counter++;\u00a0 \u00a0 \u00a0if (counter >= 180) {\u00a0 \u00a0 \u00a0 \u00a0toSleep = true;\u00a0 \u00a0 \u00a0 \u00a0counter = 0;\u00a0 \u00a0 \u00a0}\u00a0 \u00a0 lastMillis = millis();\u00a0 }\u00a0 if (toSleep) {\u00a0 \u00a0 LowPower.sleep(TIME_SLEEP);\u00a0 \u00a0 toSleep = false;\u00a0 }}\u00a0void mqttpublishSingle() { int t = counter; String data = String(t, DEC); int length = data.length(); char msgBuffer[length]; data.toCharArray(msgBuffer,length+1); Serial.println(msgBuffer); // Create a topic string and publish data to ThingSpeak channel feed. //String topicString ='channels/' + String( channelID ) + '/publish/'+String(writeAPIKey); String topicString ='channels/' + String( channelID ) + '/publish/fields/field8/'+String(writeAPIKey); length=topicString.length(); char topicBuffer[length]; topicString.toCharArray(topicBuffer,length+1); client.publish( topicBuffer, msgBuffer);lastConnectionTime = millis();}#################################\u00a0Thank you very much", "num_user_post": " 16", "author": "eplantes"}, {"date": "April 12, 2018 - 3:39 pm", "content": "I suspect your application is being affected by the 1 second update limit.\u00a0 Because you are publishing at exactly 1000ms intervals, there is no room for error when a communication delay occurs.\u00a0 There are few layers between your Arduino and your ThingSpeak channel.\u00a0 If one of those layers introduces a slight delay, then the next data point may get rejected because it hits the ThingSpeak api before one second has elapsed.\u00a0 Try changing the publish interval to 1500ms and see if it makes a difference.\u00a0 I realize this is counter productive if your device is running from a battery as the GSM radio will be on longer.\u00a0 However it will be something to try.I would also like to mention the bulk update feature which seems like a perfect fit for your application.\u00a0 With a bulk update, data can be collected over time, then uploaded with a single api call.\u00a0 The transaction is only available using the REST interface.\u00a0Here is a link to the bulk update documentation.\u00a0 Be sure to check out the Arduino MKR 1000 example link near the end of the pagehttps://www.mathworks.com/help/thingspeak/bulkwritejsondata.html\u00a0\u00a0 \u00a0", "num_user_post": " 34", "author": "JasonW"}, {"date": "April 13, 2018 - 1:52 pm", "content": "Hello JasonW.Thank you very much for your comment. I will try to change the publish interval between request, for example from 1 second to 1,5 or 2 seconds and see if some change happens.On another hand, I was being testing the bulk update feature in this same scenario (arduino over GSM network) a few weeks ago, but unfortunalety I experimented some problems too. For some strange reason, I only can send bulk updates when the size packet is about 256 bytes or less, but not longer. Every time I send I packet with size longer than 256 bytes, I receive an error. I don't know if this error is caused by the library (MKRGSM) or is a limitation of the GSM chip. This supose a serious inconvenience for me, because I need wait 15 seconds or more to send the next bulk update.I can attach some logs with the erros showed, but I supose it will be better open a new topic for explain that.Thank you very much for your comments", "num_user_post": " 16", "author": "eplantes"}, {"date": "April 24, 2018 - 9:34 am", "content": "I'm pretty sure there is at least a limitation in the library, if not in the chip as well.I see you opened a new thread here: https://community.thingspeak.com/forum/arduino/testing-bulk-update-feature-with-arduino-mkr-gsm/#p5752Sorry for the repeat.You can send multiple packets in one request.For example if your POST data was:{'write_api_key': 'WRITE_API_KEY','updates': [{'created_at': '2018-01-30 10:26:2 -0500','field1': '1.0','field2': '2.0'},{'created_at': '2018-02-02 11:27:27 -0500','field1': '1.1','field2': '2.2','status': 'well done'}]}You can do the following (syntax not tested - psuedocode):client.print('{'write_api_key': 'WRITE_API_KEY','updates': [');client.print('{'created_at': '2018-01-30 10:26:2 -0500','field1': '1.0','field2': '2.0'},');client.print('{'created_at': '2018-02-02 11:27:27 -0500','field1': '1.1','field2': '2.2','status': 'well done'}');client.println(']}');...which avoids the 265 character limit.  Remember to be careful with .print and .println, the protocol is sensitive to line endings.", "num_user_post": " 401", "author": "cstapels"}]}, {"url": "https://community.thingspeak.com/forum/arduino/uploading-via-sim800-gsm-module-using-at-commands/", "posts": [{"date": "March 25, 2018 - 12:56 pm", "content": "Does anyone know what is wrong when I am able to complete a send with SEND OK but the channel is not updated?\u00a0 My Arduino code is using TCP and is it very simple.\u00a0 I think I am suppose to get the update number from as feedback but i never get it.\u00a0 The channelcan be updated using the GET command using POSTMAN and via a browser.\u00a0 I have run out of ideas.\u00a0 Do you have any suggestions?David\u00a0#include <SoftwareSerial.h>#define SIM_800_TX 7#define SIM_800_RX 6int midZ=2000;//time delaysint minZ=500;int maxZ=5000;SoftwareSerial MySerial(SIM_800_RX, SIM_800_TX); // RX, TXvoid setup() {Serial.begin(9600); while (!Serial); MySerial.begin(9600);delay(midZ); MySerial.println('at+csq'); delay(minZ); feedback(); MySerial.println('at+cipshut'); delay(minZ); feedback(); MySerial.println('at+cstt='giffgaff.com','giffgaff','''); feedback(); MySerial.println('at+ciicr');//start wireless connection cellular network feedback(); MySerial.println('at+cifsr');//enquire regarding the IP address allocated feedback(); MySerial.println('at+cipstart='TCP','184.106.153.149','80'');//connect to the ThingSpeak update URL (https://api.thingspeak.com) feedback(); MySerial.println('at+cipsend=71');//declare the number of bytes (characters) I want to send feedback(); MySerial.print('GET https://api.thingspeak.com/update?');//this is a constant beginning for the GET command and is as provided by ThingSpeak feedback(); MySerial.print('api_key=IVEJWZMAPDSP2AXB');//the channel API key provided by ThingSpeakfeedback(); MySerial.print('&field1=');feedback(); MySerial.println('5');//the value that I want to post to field 1 feedback(); MySerial.println('at+cipack');//ask for acknowledge detailsfeedback(); MySerial.println('at+cipclose');//close the IP connection feedback();}void loop() {if (MySerial.available()) {Serial.write(MySerial.read()); } if (Serial.available()) { MySerial.write(Serial.read()); }}void feedback() { delay(midZ); while (MySerial.available()) { Serial.write(MySerial.read()); }}", "num_user_post": " 4", "author": "SailSenseTech"}, {"date": "March 30, 2018 - 6:49 am", "content": "The secret is a double MySerial.println(); after the request string is entered.\u00a0 This can be added to the end of the string as ''.\u00a0 If the CIPSEND command is specifying the length of the message this needs to be 4 more than the number of characters in the basic GET /update?key=.... string.", "num_user_post": " 4", "author": "SailSenseTech"}, {"date": "April 23, 2018 - 4:22 pm", "content": "Hi SailSense,I have been struggling with exactly the same problem the past 3 weeks.  I receive validation 'SEND OK', but the field does not update.  USING Postman or browser result in a successful update.  Have you managed to sort the coding and update successfully?  Would you mind sending me the coding please?", "num_user_post": " 1", "author": "KR46"}]}, {"url": "https://community.thingspeak.com/forum/arduino/mkr1000-plant-communicator-only-uploading-2-data-points/", "posts": [{"date": "March 31, 2018 - 1:04 am", "content": "Hello,I am new to IoT and am currently using the Arduino MKR1000 board. following the 'Plant Communicator'\u00a0project (https://create.arduino.cc/projecthub/arduino/plant-communicator-7ea06f) I am having an issue uploading more than 2 data points to my channel.I am successfully uploading the first two data points right after uploading my sketch (pasted below) to the board, looking at my serial monitor I can see that the ThingSpeak.writeFields() is still executing but the data is not being sent to my channel. resetting the board or re-uploading the code will send 2 other data points but no more. Could I be losing connection to the thingspeak client somehow, what is a good way to determine if my connection is still fine?\u00a0#include <WiFi101.h>#include<WiFiSSLClient.h>#include 'ThingSpeak.h'const char* ssid = 'oassali'; // your network SSID (name)const char* password = 'oMar1331'; // your network passwordWiFiClient ThingSpeakClient;unsigned long myChannelNumber = 463969;const char* myWriteAPIKey = 'U4HV0M9EYTFLHUW4';int lightPin = A0; //the analog pin the light sensor is connected toint tempPin = A1; //the analog pin the TMP36's Vout (sense) pin is connected toint moisturePin = A2;void setup() { Serial.begin(9600); while (!Serial); delay(2000); Serial.print('Connecting Wifi: '); Serial.println(ssid); while (WiFi.begin(ssid, password) != WL_CONNECTED) { Serial.print('.'); delay(500); } Serial.println(''); Serial.println('WiFi connected'); ThingSpeak.begin(ThingSpeakClient);}void loop() { ThingSpeak.setField(1, get_light()); ThingSpeak.setField(2, get_temperature()); ThingSpeak.setField(3, get_average_moisture()); Serial.println(get_light()); Serial.println(get_temperature()); Serial.println(get_average_moisture()); ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey); Serial.println('message sent to cloud'); delay(60000); // send values every 1 minute}float get_temperature() { int reading = analogRead(tempPin); float voltage = reading * 3.3; voltage /= 1024.0; // Print tempeature in Celsius float temperatureC = (voltage - 0.5) * 100 ; //converting from 10 mv per degree wit 500 mV offset // Convert to Fahrenheit float temperatureF = (temperatureC * 9.0 / 5.0) + 32.0; return temperatureC;}int get_average_moisture() { // make an average of 10 values to be more accurate int tempValue = 0; // variable to temporarly store moisture value for (int a = 0; a < 10; a++) { tempValue += analogRead(moisturePin); delay(10); } return tempValue / 10;}int get_light() { int light_value = analogRead(A0); return light_value;}", "num_user_post": " 1", "author": "oassali"}, {"date": "April 1, 2018 - 12:35 am", "content": "If you put the line#define\u00a0PRINT_DEBUG_MESSAGESat the top of your code the thingspeak library will print lots of debugging output to the serial monitor- maybe this might help you find whats going on.", "num_user_post": " 271", "author": "rw950431"}, {"date": "April 1, 2018 - 8:30 pm", "content": "Getting extra output from the library is a good idea.\u00a0 If you think your connection is intermittent, you can put a check on the connection in your main loop.\u00a0 Have a look at the sonar example in the documentation to see this method.\u00a0 That example was tested on a MKR1000.\u00a0There may also be an issue with the WiFi\u00a0 101 library.\u00a0 Have a look at this thread. You may have to\u00a0 consider downgrading your wifi101 library version.", "num_user_post": " 401", "author": "cstapels"}]}, {"url": "https://community.thingspeak.com/forum/arduino/uploading-multiple-fields-to-thingspeak-from-arduino/", "posts": [{"date": "January 30, 2018 - 8:59 am", "content": "Hi all,\u00a0i've come slightly unstuck attempting to send data to thingspeak, and was hoping someone with a better knowledge my be able to point me in the right direction.I'm attempting to send pressure and temperature information collected using a MS5803-14(and later electrical conductivity), and I have been using the write multiple voltage example as a basis.I was trying to use\u00a0ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey); to update multiple fields at once. However, when multiple fields have been set using\u00a0ThingSpeak.setField(1,pressure); nothing is written to thing speak.The strange element is that if I comment out one of the setField lines, the data will upload normally. This works if I comment out either of the factors i'm trying to upload.\u00a0Additionally if I use\u00a0ThingSpeak.writeField(myChannelNumber, 1, pressure, myWriteAPIKey); with a delay followed byThingSpeak.writeField(myChannelNumber, 2, temperature, myWriteAPIKey);the data will also upload.the arduino is obviously calculating the data correctly as well, as values will print to serial.its only in the combination of the data that thinspeak stops receiving the data.\u00a0Many thanks\u00a0#include 'ThingSpeak.h'#include <OneWire.h>#include <Wire.h>#include <MS5803_14.h>\u00a0#define USE_ETHERNET_SHIELD\u00a0#include <SPI.h>#include <Ethernet.h>byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED};EthernetClient client;\u00a0MS_5803 sensor = MS_5803(4096);float pressure;float temperature;\u00a0unsigned long myChannelNumber = XXXXXXXX;const char * myWriteAPIKey = 'XXXXXXXXXXX';void setup() { Serial.begin (9600);Ethernet.begin(mac);\u00a0ThingSpeak.begin(client);sensor.initializeMS_5803();delay(3000);}void loop() {\u00a0sensor.readSensor(); pressure = sensor.pressure(); temperature = sensor.temperature();\u00a0ThingSpeak.setField( 1, (float) pressure); ThingSpeak.setField( 2, (float) temperature); ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey);delay(20000); // ThingSpeak will only accept updates every 15 seconds.}", "num_user_post": " 4", "author": "Bird"}, {"date": "January 31, 2018 - 9:52 am", "content": "Have you downloaded the channel data to make sure its not a scaling problem and your data it updating but you don't see it?\u00a0 Does the number of entries change after a post, even if you don't see that data?Your code looks fine to me, but you might want to remove the cast to float in the .setField command.\u00a0\u00a0ThingSpeak.setField( 1, (float) pressure);toThingSpeak.setField( 1, pressure);If that still doesn't work, you could consider converting your variables to a string before uploading it.\u00a0 ThingSpeak will still interpret the string as a float for plotting as long at there aren't any other characters in the string (like # or ')\u00a0ThingSpeak.setField( 1, String(pressure));But that method has all the extra problems of bringing along the string class.One other thing to try is to output pressure and temperature variables to the serial monitor before you write to ThingSpeak just to make sure they read correctly.Let us know if any that works.\u00a0 If it doesn't, you can update multiple fields without the library, though its a bit harder.", "num_user_post": " 401", "author": "cstapels"}, {"date": "January 31, 2018 - 11:51 am", "content": "Thanks for looking at it, I'm not going to be able to have a look for a couple of days but I'll update then.Off the top of my head, I think that nothing being added, they\u00a0 number of entries was not increasing (but i'll double check this) and I don't think the float setfield command would be causing the issue, as if one of the two lines of setfield was commented out the data would then upload for the other field.\u00a0\u00a0Anyway, i'll update soon.\u00a0thanks again for your help", "num_user_post": " 4", "author": "Bird"}, {"date": "February 2, 2018 - 7:09 am", "content": "just to update:\u00a0It was posting, just with no values.Converting to a string as suggested worked.\u00a0Thanks very much!", "num_user_post": " 4", "author": "Bird"}, {"date": "March 15, 2018 - 4:55 am", "content": "Hi everybody,I'm completely noob to arduino (Thingspeak also) and I have tried to follow this tutorial:\u00a0https://create.arduino.cc/projecthub/arduino/plant-communicator-7ea06f?ref=part&ref_id=54617&offset=1As other users I have seen in this forum, I can't upload the data to Thingspeak. Everything works fine until the command\u00a0ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey); then nothing happens. Communications are OK, due to\u00a0<span class='hljs-string'>'WiFi connected' </span>message. And also I can see the data in the console with\u00a0<span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>println.</span>I have tried all this things:Instead of\u00a0ThingSpeak.setField(<span class='hljs-number'>1</span>, get_light()); --&gt;\u00a0ThingSpeak.setField(<span class='hljs-number'>1</span>, String(get_light()));Assign to a variable the return of the function\u00a0get_light() and after this\u00a0ThingSpeak.setField(<span class='hljs-number'>1</span>, variable) or String(variable). Nothing happens again.I have succesfully checked that the channel can be written, with https://api.thingspeak.com/update?api_key=XXXXXXXXXX&field1=400&field2=123. Works without problem, I can see the data in the plot.\u00a0Also I have compared that the y-axis of the plot with my data units.I'm completely stucked...any idea?This is the code I have copied/pasted directly from the tutorial. Thanks a lot!<span class='hljs-meta'>#<span class='hljs-meta-keyword'>include</span> <span class='hljs-meta-string'>&lt;WiFi101.h&gt; </span></span><span class='hljs-meta'>#<span class='hljs-meta-keyword'>include</span><span class='hljs-meta-string'>&lt;WiFiSSLClient.h&gt; </span></span><span class='hljs-meta'>#<span class='hljs-meta-keyword'>include</span> <span class='hljs-meta-string'>'ThingSpeak.h'</span> </span><span class='hljs-keyword'>const</span> <span class='hljs-keyword'>char</span>* ssid = SECRET_SSID;    <span class='hljs-comment'>//  your network SSID (name) </span><span class='hljs-keyword'>const</span> <span class='hljs-keyword'>char</span>* password = SECRET_PSWD;  <span class='hljs-comment'>// your network password </span><span class='hljs-built_in'>WiFiClient</span>  ThingSpeakClient; <span class='hljs-keyword'>unsigned</span> <span class='hljs-keyword'>long</span> myChannelNumber = <span class='hljs-number'>356392</span>; <span class='hljs-keyword'>const</span> <span class='hljs-keyword'>char</span> * myWriteAPIKey = SECRET_WRITE_API; <span class='hljs-keyword'>int</span> lightPin = A0; <span class='hljs-comment'>//the analog pin the light sensor is connected to </span><span class='hljs-keyword'>int</span> tempPin = A1; <span class='hljs-comment'>//the analog pin the TMP36's Vout (sense) pin is connected to </span><span class='hljs-keyword'>int</span> moisturePin = A2; <span class='hljs-keyword'>void</span> <span class='hljs-built_in'>setup</span>() {  <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>begin</span>(<span class='hljs-number'>9600</span>);  <span class='hljs-built_in'>while</span> (!<span class='hljs-built_in'>Serial</span>);  <span class='hljs-built_in'>delay</span>(<span class='hljs-number'>2000</span>);  <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>print</span>(<span class='hljs-string'>'Connecting Wifi: '</span>);  <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>println</span>(ssid);  <span class='hljs-built_in'>while</span> (<span class='hljs-built_in'>WiFi</span>.<span class='hljs-built_in'>begin</span>(ssid, password) != WL_CONNECTED) {    <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>print</span>(<span class='hljs-string'>'.'</span>);    <span class='hljs-built_in'>delay</span>(<span class='hljs-number'>500</span>);  }  <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>println</span>(<span class='hljs-string'>''</span>);  <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>println</span>(<span class='hljs-string'>'WiFi connected'</span>); } <span class='hljs-keyword'>void</span> <span class='hljs-built_in'>loop</span>() {  ThingSpeak.setField(<span class='hljs-number'>1</span>, get_light());  ThingSpeak.setField(<span class='hljs-number'>2</span>, get_temperature());  ThingSpeak.setField(<span class='hljs-number'>3</span>, get_average_moisture());  ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey);  <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>println</span>(<span class='hljs-string'>'message sent to cloud'</span>);  <span class='hljs-built_in'>delay</span>(<span class='hljs-number'>60000</span>); <span class='hljs-comment'>// send values every 1 minute </span>} <span class='hljs-keyword'>float</span> get_temperature() {  <span class='hljs-keyword'>int</span> reading = <span class='hljs-built_in'>analogRead</span>(tempPin);  <span class='hljs-keyword'>float</span> voltage = reading * <span class='hljs-number'>3.3</span>;  voltage /= <span class='hljs-number'>1024.0</span>;  <span class='hljs-comment'>// Print tempeature in Celsius </span> <span class='hljs-keyword'>float</span> temperatureC = (voltage - <span class='hljs-number'>0.5</span>) * <span class='hljs-number'>100</span> ; <span class='hljs-comment'>//converting from 10 mv per degree wit 500 mV offset </span> <span class='hljs-comment'>// Convert to Fahrenheit </span> <span class='hljs-keyword'>float</span> temperatureF = (temperatureC * <span class='hljs-number'>9.0</span> / <span class='hljs-number'>5.0</span>) + <span class='hljs-number'>32.0</span>;  <span class='hljs-built_in'>return</span> temperatureC; } <span class='hljs-keyword'>int</span> get_average_moisture() { <span class='hljs-comment'>// make an average of 10 values to be more accurate </span> <span class='hljs-keyword'>int</span> tempValue = <span class='hljs-number'>0</span>; <span class='hljs-comment'>// variable to temporarly store moisture value </span> <span class='hljs-built_in'>for</span> (<span class='hljs-keyword'>int</span> a = <span class='hljs-number'>0</span>; a &lt; <span class='hljs-number'>10</span>; a++) {    tempValue += <span class='hljs-built_in'>analogRead</span>(moisturePin);    <span class='hljs-built_in'>delay</span>(<span class='hljs-number'>10</span>);  }  <span class='hljs-built_in'>return</span> tempValue / <span class='hljs-number'>10</span>; } <span class='hljs-keyword'>int</span> get_light() {  <span class='hljs-keyword'>int</span> light_value = <span class='hljs-built_in'>analogRead</span>(A0);  <span class='hljs-built_in'>return</span> light_value; } ", "num_user_post": " 2", "author": "MrFrames"}, {"date": "March 15, 2018 - 5:03 am", "content": "MrFrames said  Hi everybody, I'm completely noob to arduino (Thingspeak also) and I have tried to follow this tutorial:\u00a0 https://create.arduino.cc/projecthub/arduino/plant-communicator-7ea06f?ref=part&ref_id=54617&offset=1 As other users I have seen in this forum, I can't upload the data to Thingspeak. Everything works fine until the command\u00a0ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey); then nothing happens. Communications are OK, due to\u00a0<span class='hljs-string'>'WiFi connected' </span>message. And also I can see the data in the console with\u00a0<span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>println.</span> I have tried all this things:Instead of\u00a0ThingSpeak.setField(<span class='hljs-number'>1</span>, get_light()); --&gt;\u00a0ThingSpeak.setField(<span class='hljs-number'>1</span>, String(get_light()));Assign to a variable the return of the function\u00a0get_light() and after this\u00a0ThingSpeak.setField(<span class='hljs-number'>1</span>, variable) or String(variable). Nothing happens again.I have succesfully checked that the channel can be written, with https://api.thingspeak.com/update?api_key=XXXXXXXXXX&field1=400&field2=123. Works without problem, I can see the data in the plot.\u00a0Also I have compared that the y-axis of the plot with my data units. I'm completely stucked...any idea? This is the code I have copied/pasted directly from the tutorial. Thanks a lot!<span class='hljs-meta'>#<span class='hljs-meta-keyword'>include</span>  </span><br /><span class='hljs-meta'>#<span class='hljs-meta-keyword'>include</span> </span><br /><span class='hljs-meta'>#<span class='hljs-meta-keyword'>include</span> <span class='hljs-meta-string'>'ThingSpeak.h'</span> </span><br /><span class='hljs-keyword'>const</span> <span class='hljs-keyword'>char</span>* ssid = SECRET_SSID;    <span class='hljs-comment'>//  your network SSID (name) </span><br /><span class='hljs-keyword'>const</span> <span class='hljs-keyword'>char</span>* password = SECRET_PSWD;  <span class='hljs-comment'>// your network password </span><br /><span class='hljs-built_in'>WiFiClient</span>  ThingSpeakClient; <br /><span class='hljs-keyword'>unsigned</span> <span class='hljs-keyword'>long</span> myChannelNumber = <span class='hljs-number'>356392</span>; <br /><span class='hljs-keyword'>const</span> <span class='hljs-keyword'>char</span> * myWriteAPIKey = SECRET_WRITE_API; <br /><span class='hljs-keyword'>int</span> lightPin = A0; <span class='hljs-comment'>//the analog pin the light sensor is connected to </span><br /><span class='hljs-keyword'>int</span> tempPin = A1; <span class='hljs-comment'>//the analog pin the TMP36's Vout (sense) pin is connected to </span><br /><span class='hljs-keyword'>int</span> moisturePin = A2; <br /><span class='hljs-keyword'>void</span> <span class='hljs-built_in'>setup</span>() { <br /> <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>begin</span>(<span class='hljs-number'>9600</span>); <br /> <span class='hljs-built_in'>while</span> (!<span class='hljs-built_in'>Serial</span>); <br /> <span class='hljs-built_in'>delay</span>(<span class='hljs-number'>2000</span>); <br /> <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>print</span>(<span class='hljs-string'>'Connecting Wifi: '</span>); <br /> <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>println</span>(ssid); <br /> <span class='hljs-built_in'>while</span> (<span class='hljs-built_in'>WiFi</span>.<span class='hljs-built_in'>begin</span>(ssid, password) != WL_CONNECTED) { <br />   <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>print</span>(<span class='hljs-string'>'.'</span>); <br />   <span class='hljs-built_in'>delay</span>(<span class='hljs-number'>500</span>); <br /> } <br /> <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>println</span>(<span class='hljs-string'>''</span>); <br /> <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>println</span>(<span class='hljs-string'>'WiFi connected'</span>); <br />} <br /><span class='hljs-keyword'>void</span> <span class='hljs-built_in'>loop</span>() { <br /> ThingSpeak.setField(<span class='hljs-number'>1</span>, get_light()); <br /> ThingSpeak.setField(<span class='hljs-number'>2</span>, get_temperature()); <br /> ThingSpeak.setField(<span class='hljs-number'>3</span>, get_average_moisture()); <br /> ThingSpeak.writeFields(myChannelNumber, myWriteAPIKey); <br /> <span class='hljs-built_in'>Serial</span>.<span class='hljs-built_in'>println</span>(<span class='hljs-string'>'message sent to cloud'</span>); <br /> <span class='hljs-built_in'>delay</span>(<span class='hljs-number'>60000</span>); <span class='hljs-comment'>// send values every 1 minute </span><br />} <br /><span class='hljs-keyword'>float</span> get_temperature() { <br /> <span class='hljs-keyword'>int</span> reading = <span class='hljs-built_in'>analogRead</span>(tempPin); <br /> <span class='hljs-keyword'>float</span> voltage = reading * <span class='hljs-number'>3.3</span>; <br /> voltage /= <span class='hljs-number'>1024.0</span>; <br /> <span class='hljs-comment'>// Print tempeature in Celsius </span><br /> <span class='hljs-keyword'>float</span> temperatureC = (voltage - <span class='hljs-number'>0.5</span>) * <span class='hljs-number'>100</span> ; <span class='hljs-comment'>//converting from 10 mv per degree wit 500 mV offset </span><br /> <span class='hljs-comment'>// Convert to Fahrenheit </span><br /> <span class='hljs-keyword'>float</span> temperatureF = (temperatureC * <span class='hljs-number'>9.0</span> / <span class='hljs-number'>5.0</span>) + <span class='hljs-number'>32.0</span>; <br /> <span class='hljs-built_in'>return</span> temperatureC; <br />} <br /><span class='hljs-keyword'>int</span> get_average_moisture() { <span class='hljs-comment'>// make an average of 10 values to be more accurate </span><br /> <span class='hljs-keyword'>int</span> tempValue = <span class='hljs-number'>0</span>; <span class='hljs-comment'>// variable to temporarly store moisture value </span><br /> <span class='hljs-built_in'>for</span> (<span class='hljs-keyword'>int</span> a = <span class='hljs-number'>0</span>; a &lt; <span class='hljs-number'>10</span>; a++) { <br />   tempValue += <span class='hljs-built_in'>analogRead</span>(moisturePin); <br />   <span class='hljs-built_in'>delay</span>(<span class='hljs-number'>10</span>); <br /> } <br /> <span class='hljs-built_in'>return</span> tempValue / <span class='hljs-number'>10</span>; <br />} <br /><span class='hljs-keyword'>int</span> get_light() { <br /> <span class='hljs-keyword'>int</span> light_value = <span class='hljs-built_in'>analogRead</span>(A0); <br /> <span class='hljs-built_in'>return</span> light_value; <br />} \u00a0\u00a0Sorry for the format , I'm not able to edit the post again!", "num_user_post": " 2", "author": "MrFrames"}]}]}